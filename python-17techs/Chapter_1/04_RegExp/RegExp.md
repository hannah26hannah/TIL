# Index

- [String](#string)
- [Number](#number)
- [Character Class](#character-class)
- [Meta Characters](#meta-characters)
- [Flag](#flag)
- [Real Example](#real-example)
- [Reference](#reference)

# Regular Expression

정규 표현식은 주어진 문자열 내 문자 검색과 교체를 위한 패턴.

- 사용자가 자유롭게 입력 가능한 폼 데이터를 검증하거나,
- 웹 페이지 요청 주소에서 필요한 문자열을 찾을 때 유용

범용 고유 식별자(UUID)처럼 특정 규칙이 있는 식별자나 사용자 이름, IP 주소, URL 등 여러 문자열로부터 패턴을 가진 정보를 찾아야 할 때 유용하게 사용 가능하다.

# Reg Basic

- Python에서는 `re` 모듈 : `findall()`, `search()`, `split()` 같은 여러 메서드를 제공한다.

```python
import re

def find_pattern(pattern, string):
    match = re.findall(pattern, string)
    if not match:
        print("일치하는 데이터가 없습니다.");
        return
    print("일치하는 데이터를 찾았습니다. {0}".format(match))
```

pattern 인수는 정규 표현식, string 인수는 패턴을 검사할 문자열

- JavaScript에서는 표준 내장 객체인 `RegExp` 객체와 문자열 메서드를 조합해 사용한다.
- reg는 pattern과 선택적으로 사용하는 flag로 구성된다.

JavaScript에서 정규식을 만드는 두 가지 방법

```javascript
regexp = new RegExp("pattern", "flags");

regexp = /pattern/;
regexp = /pattern/gim; // flag is optional

// 슬래시는 정규 표현식 생성을 위한 역할로, 문자열을 구분하기 위해 ""를 사용하는 것과 마찬가지이다.
// 위 두 가지 문법을 통해 내장 클래스 regexp의 인스턴스가 생성되었다.
```

- `/`를 사용한 방법 : `${..}`처럼 내부에 표현식 사용 불가. 매우 정적이다.
- `new RegExp`를 사용한 방법 : 동적으로 생성된 패턴으로 정규 표현식 만들어야 할 때.

```javascript
let tag = prompt("어떤 태그를 찾고 싶나요?", "h2");
let regexp = new RegExp(`<${tag}>`);
```

# String

## 특정 문자 1개 찾기

'Hello World' 안에서 `o` 를 찾는다. 찾고자 하는 특정 문자가 바로 패턴이 된다.

```python
find_pattern('o', 'Hello World') # 일치하는 패턴을 찾았습니다. ['o', 'o']
```

## 영문자 1개 찾기

### 소문자 1개 : [a-z] 패턴

소문자만 찾기 때문에 대문자, 숫자, 특수 문자, 공백은 무시한다.

```python
find_pattern('[a-z]', 'Hello World, 1, 2, 3, 4, 5')
# 일치하는 데이터를 찾았습니다. ['e', 'l', 'l', 'o', 'o', 'r', 'l', 'd']
```

### 대문자 1개 : [A-Z]

```python
find_pattern('[A-Z]', 'Hello World 1, 2, 3, 4, 5')
# 일치하는 데이터를 찾았습니다. ['H', 'W']
```

### 대소문자 1개 [a-zA-Z]

```python
find_pattern('[a-zA-Z]', 'Hello World, 1, 2, 3, 4, 5')
# 일치하는 데이터를 찾았습니다. ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd']
```

# 하나 이상의 문자 찾기

- JavaScript에서 `str.match()` 검색하기 `01_str_match.js`
- `str.replace(pattern, replacement)`로 치환하기 `02_str_replace.js`
  - 문자열인 두 번째 인수, replacement에 아래의 특수 문자를 넣어 여러 방식으로 문자열을 교체할 수 있다.
    - `$&` : 패턴과 일치하는 부분 문자열
    - `` $`  `` : 패턴과 일치하기 전 문자열의 일부를 삽입한다.
    - `$'` : 패턴과 일치한 후 문자열의 일부를 삽입한다.
    - `$n` : `n`이 1-2자리의 숫자일 경우, `n`번째 괄호의 컨텐츠를 삽입한다.
    - `$<name>` : 주어진 `name`을 괄호로 감싼 컨텐츠로 삽입한다.
    - `$$` : `$` 문자를 삽입한다.

## 소문자 문자열 찾기

### `[a-z]+`

```python
find_pattern('[a-z]+', r'Hello World, 1, 2, 3, 4, 5, !@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다. ['ello', 'orld']
```

## anchor : 문자열의 시작 `^`과 끝 `$`

`05_anchor.js`

만일 'foo'라는 문자열을 매치하되, 'foo'로만 이루어진 문자열을 찾고자 한다면,

```javascript
// JavaScript
let regexp = /[^foo$]/; // "foo"
regexp = /[^foo]/; // "foo"로 시작하는 모든 문자열 ex foooooo
regexp = /[foo$]/; // "foo"로 끝나는 모든 문자열 ex zoooofoo
```

만일 위처럼 지정하지 않으면 'fooooo'가 매칭될 수도 있다.
`^`(캐럿 기호)는 문자열의 시작을 의미하고, `$`(달러 기호)는 문자열의 마지막을 의미한다. (단, 개행 문자는 포함되지 않는다.)

빈 문자열을 찾을 때도 `^`, `$` 기호를 사용할 수 있다.

```javascript
console.log("  ".match(/^\s+$|^$/gi));
console.log("".match(/^\s+$|^$/gi));
```

## 지정한 길이의 문자열 찾기

고정된 길이를 지정할 때는 중괄호(`{}`)를 사용한다.

### [a-zA-Z0-9,]{number}

- `[a-z0-9,]` : 주어진 문자가 소문자, 숫자, 쉼표 문자 중 1개인지 검사
- `{number}` : 문자열의 길이가 정확히 number인지 검사

즉, 소문자, 숫자, 쉼표 중 1개와 일치하는 문자가 정확히 3번 등장하는지 검사.

```python
find_pattern('[a-z0-9,]{3}', r'Hello World, 1,2,3,4,5, !@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다. ['ell', 'orl', '1,2', ',3,', '4,5']
```

### **[a-z0-9,]{3,5}**

- `{min,max}` : 최소 문자열 길이, 최대 문자열 길이를 의미.
- `{min,}` : 최소 길이만 지정하고 싶을 때
- `{,max}` : 최대 길이만 지정하고 싶을 때

👀 중괄호 안에서 쉼표에 주의할 것

```python
find_pattern('[a-z0-9,]{3,5}', r'Hello World, 1,2,3,4,5, !@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다 ['hello', 'orld,', '1,2,3', ',4,5,']
```

그외,

- `^[a-zA-Z]{3}` : 주어진 문자열의 첫 3글자가 소문자 또는 대문자인지 검사.

```python
find_pattern('^[a-zA-Z]{3}', r'Hello World, 1,2,3,4,5, !@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다 ['Hel',]
```

- `[^a-zA-Z0-9]{3}$` : 마지막 세 글자가 소문자, 대문자, 숫자가 아닌 특수문자인지를 검사.

```python
find_pattern('[^a-zA-Z0-9]{3}$', r'Hello World, 1,2,3,4,5, !@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다 [ '\\[]' ]
```

# Number

### **[0-9] 패턴**

문자와 공백, 쉼표(`,`)를 제외한 숫자 5개만 일치한다.

```python
find_pattern('[0-9]', 'Hello World, 1, 2, 3, 4, 5')
# 일치하는 데이터를 찾았습니다.  ['1', '2', '3', '4', '5']
```

문자와 숫자를 함께 출력할 때는

### **[a-zA-Z0-9]**

```python
find_pattern('[a-zA-Z0-9]', 'Hello World, 1, 2, 3, 4, 5')
# 일치하는 데이터를 찾았습니다.  ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd', '1', '2', '3', '4', '5']
```

# Character Class

`+7(903)-123-45-67` 같은 전화번호에서 숫자만 남겨 `79035419441`로 만드는 경우가 있을 것이다. 이 경우엔 숫자가 아닌 문자를 모두 찾아 지울 수 있다. 이때 '문자 클래스(character class)'를 사용한다.

문자 클래스는 특정 집합에 포함된 모든 기호에 일치하는 특별한 표현이다.

예제 : `04_character_class.js`

아래는 자주 사용하는 문자 클래스의 종류

- `\d` : digit 숫자 `0`에서 `9` 사이의 아무 숫자 하나에 대응한다.
- `\s` : space 탭(`\t`), 줄바꿈(`\n`)을 비롯해 `\v`, `\f`, `\r`을 포함하는 공백 기호
- `\w` : word '단어에 들어가는' 문자로, 라틴 문자나 숫자, 밑줄(`_`)을 포함한다. 비라틴 문자(키릴 문자나 힌디 문자 등)은 `\w`에 포함되지 않는다.

`\d\s\w`는 `1 a`처럼 '숫자' 뒤에 '공백 문자' 뒤에 '단어에 들어가는 문자'를 의미한다.

regular expression에는 일반 기호와 문자 클래스를 같이 사용할 수 있다.
`CSS\d`는 `CSS` 뒤에 숫자 하나가 있는 문자열과 일치한다.

## 반대 클래스

모든 문자 클래스에는 '반대' 클래스가 있다. 같은 글자로 표기하되, 대문자로 쓴다.
즉, 해당 문자를 제외한 모든 문자에 일치한다는 의미이다.

- `\D` : 숫자가 아닌 문자. `\d`에 일치하지 않는 일반 글자 등의 모든 문자
- `\S` : 공백이 아닌 문자. `\s`에 일치하지 않는 일반 글자 등의 모든 문자.
- `\W` : 단어에 들어가지 않는 문자. `\w`와 일치하지 않는 비라틴 문자나 공백 등의 문자

# Meta Characters

주의할 점은 역슬래시(`\`)를 추가해야 한다. 대괄호나 슬래시 같은 특수문자를 찾을 때 역슬래시를 추가하지 않으면, 대괄호는 찾아야할 문자가 아닌 정규 표현식의 규칙으로 오인하기 때문이다.

이처럼 규칙의 일부로 사용되는 문자나 단어는 **예약어**라고 한다.

- 대괄호를 찾을 때 : `[\\[\\]]`
- 역슬래시를 찾을 때 : `[\\\\]`

```python
find_pattern('[\\\\\\[\\]]', '!@#$%^&*()?<>\[]')

# 파이썬 언어는 문자열 앞에 r을 붙여 아래처럼 \ 를 파싱을 피할 수 있다.
# find_pattern(r'[\\\\\\[\\]]', r'!@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다. ['\\', '[', ']']
```

출력 결과 또한 언어에서 이스케이프가 필요하므로 역슬래시의 경우는 추가 역슬래시가 붙었지만, 대괄호는 예약어로 쓰지 않아 붙지 않은 것.

```python
find_pattern(r'[\\\\\\[\\]]', r'!@#$%^&*()?<>\[]')
# 일치하는 데이터를 찾았습니다. ['[]']
```

- `\w` : 특수 문자, 공백을 제외한 글자 1개를 찾을 때 사용한다.
- `\W` : 특수 문자와 공백만 찾을 때 사용한다.
- 대괄호 안 캐럿(`^`) : NOT을 의미. 캐럿 이후에 오는 패턴을 제외한 모든 글자를 찾는다. 예를 들어, `[^A-Z]` 대문자를 제외한 모든 글자 1개를 찾을 때 사용한다. 캐럿 글자를 검사하고자 한다면 역슬래시를 추가해야 한다.
- 대괄호 밖 캐럿(`^`) : 가장 처음에 오는 대문자를 찾는다. `^[A-Z]` 주어진 문자열의 첫 번째 문자가 대문자로 시작할 경우 대문자를 찾는 패턴.
- 대괄호 밖 달러(`$`) : 캐럿과 반대의 의미. 가장 마지막 글자를 검사. 마지막 글자에 달러를 추가한다. 예를 들어, `[0-9]$` 패턴은 가장 마지막에 오는 글자가 숫자인지 검사하는 것.
  - 만일, 달러가 대괄호 안에 있다면 달러 글자 1개만 찾는 패턴으로 인식한다. 달러 글자 자체를 찾을 때는 역슬래시를 필요로 하지 않는다.
- 대괄호 밖 점(`.`) : 점은 모든 글자를 포함하는 패턴. 공백을 포함한 모든 글자가 이 패턴과 일치한다. 만일 대괄호 안에서 점을 사용하면, 점 문자 1개만 찾고, 역슬래시는 필요하지 않다.

# Flag

- JavaScript와 Python은 6개의 플래그를 지원한다.
- JavaScript

  - `i` : ignore 대소문자 구분 없이 검색한다.
  - `g` : 패턴과 일치하는 모든 것을 찾는다. `g` 플래그가 없으면 패턴과 일치하는 첫 번째 결과만 반환한다.
  - `m` : 다중 행 모드(multiline mode)를 활성화.
  - `s` : `.`이 개행 문자 `\n`도 포함하도록, `dotall` 모드를 활성화한다.
  - `u` : unicode 유니코드 전체를 지원한다. 이 플래그를 활성화하면, surrogate pair를 올바르게 처리할 수 있다.
  - `y` : 문자 내 특정 위치에서 검색을 진행하는 `sticky` 모드를 활성화한다.

- Python
  - `i` : 대소문자 구분 없이 검색한다.
  - `l` : locate `\w`, `\W`, `\b`, `\B` 를 현재의 locale에 영향을 받게 한다.
  - `m` : 다중 행 모드(multiline mode)를 활성화. `^`가 문자열의 맨 처음, 각 라인의 맨 처음과 매치된다. `$`는 문자열의 맨 끝, 각 라인의 맨 끝과 매치된다.
  - `s` : `.`이 개행 문자 `\n`도 포함하도록, `dotall` 모드를 활성화한다.
  - `u` : `\w`, `\W`, `\b`, `\B`가 유니코드 문자 특성에 의존하게 한다.
  - `x` : 정규식 안의 공백은 무시딘다.

# Real Example

## 전화번호에서 숫자만 남기기

문자 클래스를 사용한다.

## 비밀번호 검증

`check_password.py`

- 대문자 최소 1개 이상
- 소문자 최소 1개 이상
- 특수문자(대문자, 소문자, 숫자가 아닌 글자) 최소 1개 이상

패턴과 일치하는 모든 문자를 검사하는 `re.findall()` 메서드와 달리, `re.search()` 메서드는 패턴이 일치하면 검사를 중단하고 결과를 바로 반환.

비밀번호 검증 시에는 소문자가 몇 개인지 검사할 필요 없이 일치/불일치 여부만 필요하므로 `re.search()`를 쓰는 것.

## 이메일 주소 검사

구분자 `@`를 중심으로 좌우를 나눠 계정과 도메인을 분리한다.

`re.split()` 메서드는 패턴과 일치하는 문자를 찾았을 때, 문자 앞과 뒤를 잘라 배열 요소로 저장한다. 모든 문자열을 검사할 때까지 반복한다.

휴대폰으로 `-` 을 기준으로 번호를 나누는 상황에서도 사용 가능하다.

```python
import re

def split_with_regex(pattern, string):
    result = re.split(pattern, string)
    if not result:
        print("일치하는 데이터가 없습니다.")
        return

    print("일치하는 데이터를 찾았습니다: {0}".format(result))

split_with_regex('@', 'hannah_you@gmail.com')
```

표준 이메일 형식은 생각보다 많은 문자를 허용한다. 예를 들면 한글 도메인 또는 한글 계정을 가진 이메일도 사용할 수 있다.

이메일 검사 정규 표현식 표준(RFC 5322)도 있다.

이메일 주소가 정규 표현식 검사를 통과하더라도 결국 사용자의 프로그램 로직이나 데이터베이스에서 허용하는 형태인지도 함께 검사해야 한다.

# Tip

정규 표현식은 Perl, POSIX, POSIX 확장 등 여러 형태로도 존재하고, 표준마다 조금씩 다르다.

정규 표현식을 사용할 때는 정규 표현식을 써도 되는지 판단하는 일이 가장 중요하다. 불필요하게 너무 많은 규칙을 적용하거나, 속도 때문에 병목 현상이 일어나면 다른 접근 방법을 고민해봐도 좋다.

정규 표현식은
POSIX(또는 POSIX 확장)
펄 호환 규칙(PCRE)가 있다.
두 규칙은 거의 유사하나, 일부 다르게 동작하는 메서드가 있다. 사용하는 언어나 소프트웨어 프레임워크에서 처음 정규 표현식을 사용한다면 어떤 표준을 사용할지 알아두는 것도 좋다.

# Reference
